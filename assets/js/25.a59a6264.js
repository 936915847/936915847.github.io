(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{513:function(s,a,t){"use strict";t.r(a);var n=t(4),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",[s._v("本文摘自于知乎，收录学习，文末附有传送门")])]),s._v(" "),t("p",[s._v("在只有双重检查锁，没有volatile的懒加载单例模式中，由于"),t("code",[s._v("指令重排序")]),s._v("的问题，我确实不会拿到"),t("code",[s._v("两个不同的单例")]),s._v("了，但我会拿到"),t("code",[s._v("“半个”单例")]),s._v("。")]),s._v(" "),t("p",[s._v("而发挥神奇作用的volatile，可以当之无愧的被称为Java并发编程中*“出现频率最高的关键字”*，常用于保持内存可见性和防止指令重排序。")]),s._v(" "),t("p",[t("strong",[s._v("保持内存可见性")])]),s._v(" "),t("p",[s._v("内存可见性（Memory Visibility）：所有线程都能看到共享内存的最新状态。")]),s._v(" "),t("h2",{attrs:{id:"失效数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#失效数据"}},[s._v("#")]),s._v(" "),t("strong",[s._v("失效数据")])]),s._v(" "),t("p",[s._v("以下是一个简单的可变整数类：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("MutableInteger")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("value "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[t("code",[s._v("MutableInteger")]),s._v("不是线程安全的，因为"),t("code",[s._v("get")]),s._v("和"),t("code",[s._v("set")]),s._v("方法都是在没有同步的情况下进行的。如果线程1调用了set方法，那么正在调用的get的线程2可能会看到更新后的value值，也"),t("strong",[s._v("可能看不到")]),s._v("。")]),s._v(" "),t("p",[s._v("解决方法很简单，将"),t("code",[s._v("value")]),s._v("声明为"),t("code",[s._v("volatile")]),s._v("变量：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("private volatile int value;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("h2",{attrs:{id:"神奇的volatile关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#神奇的volatile关键字"}},[s._v("#")]),s._v(" "),t("strong",[s._v("神奇的volatile关键字")])]),s._v(" "),t("p",[s._v("神奇的volatile关键字解决了神奇的失效数据问题。")]),s._v(" "),t("h3",{attrs:{id:"java变量的读写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java变量的读写"}},[s._v("#")]),s._v(" "),t("strong",[s._v("Java变量的读写")])]),s._v(" "),t("p",[s._v("Java通过几种原子操作完成"),t("code",[s._v("工作内存")]),s._v("和"),t("code",[s._v("主内存")]),s._v("的交互：")]),s._v(" "),t("ol",[t("li",[s._v("lock：作用于主内存，把变量标识为线程独占状态。")]),s._v(" "),t("li",[s._v("unlock：作用于主内存，解除独占状态。")]),s._v(" "),t("li",[s._v("read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。")]),s._v(" "),t("li",[s._v("load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。")]),s._v(" "),t("li",[s._v("use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。")]),s._v(" "),t("li",[s._v("assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。")]),s._v(" "),t("li",[s._v("store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。")]),s._v(" "),t("li",[s._v("write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。")])]),s._v(" "),t("h3",{attrs:{id:"volatile如何保持内存可见性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile如何保持内存可见性"}},[s._v("#")]),s._v(" "),t("strong",[s._v("volatile如何保持内存可见性")])]),s._v(" "),t("p",[s._v("volatile的特殊规则就是：")]),s._v(" "),t("ul",[t("li",[s._v("read、load、use动作必须"),t("strong",[s._v("连续出现")]),s._v("。")]),s._v(" "),t("li",[s._v("assign、store、write动作必须"),t("strong",[s._v("连续出现")]),s._v("。")])]),s._v(" "),t("p",[s._v("所以，使用volatile变量能够保证:")]),s._v(" "),t("ul",[t("li",[s._v("每次"),t("code",[s._v("读取前")]),s._v("必须先从主内存刷新最新的值。")]),s._v(" "),t("li",[s._v("每次"),t("code",[s._v("写入后")]),s._v("必须立即同步回主内存当中。")])]),s._v(" "),t("p",[s._v("也就是说，"),t("strong",[s._v("volatile关键字修饰的变量看到的随时是自己的最新值")]),s._v("。线程1中对变量v的最新修改，对线程2是可见的。")]),s._v(" "),t("h2",{attrs:{id:"防止指令重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防止指令重排"}},[s._v("#")]),s._v(" "),t("strong",[s._v("防止指令重排")])]),s._v(" "),t("p",[s._v("在基于"),t("code",[s._v("偏序关系")]),s._v("的"),t("code",[s._v("Happens-Before内存模型")]),s._v("中，指令重排技术大大提高了程序执行效率，但同时也引入了一些问题。")]),s._v(" "),t("h2",{attrs:{id:"一个指令重排的问题-被部分初始化的对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个指令重排的问题-被部分初始化的对象"}},[s._v("#")]),s._v(" "),t("strong",[s._v("一个指令重排的问题——被部分初始化的对象")])]),s._v(" "),t("h3",{attrs:{id:"懒加载单例模式和竞态条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#懒加载单例模式和竞态条件"}},[s._v("#")]),s._v(" "),t("strong",[s._v("懒加载单例模式和竞态条件")])]),s._v(" "),t("p",[s._v("一个"),t("code",[s._v("懒加载")]),s._v("的"),t("code",[s._v("单例模式")]),s._v("实现如下：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance() {\n        if ( instance == null ) { //这里存在竞态条件\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[t("code",[s._v("竞态条件")]),s._v("会导致"),t("code",[s._v("instance")]),s._v("引用被多次赋值，使用户得到两个不同的单例。")]),s._v(" "),t("h3",{attrs:{id:"dcl和被部分初始化的对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dcl和被部分初始化的对象"}},[s._v("#")]),s._v(" "),t("strong",[s._v("DCL和被部分初始化的对象")])]),s._v(" "),t("p",[s._v("为了解决这个问题，可以使用"),t("code",[s._v("synchronized")]),s._v("关键字将"),t("code",[s._v("getInstance")]),s._v("方法改为同步方法；但"),t("em",[s._v("这样串行化的单例是不能忍的")]),s._v("。所以我猿族前辈设计了"),t("code",[s._v("DCL")]),s._v("（Double Check Lock，双重检查锁）机制，使得大部分请求都不会进入阻塞代码块：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance() {\n        if ( instance == null ) { //当instance不为null时，仍可能指向一个“被部分初始化的对象”\n            synchronized (Singleton.class) {\n                if ( instance == null ) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br")])]),t("p",[s._v("“看起来”非常完美：既减少了阻塞，又避免了竞态条件。不错，但实际上仍然存在一个问题——"),t("strong",[s._v("当instance不为null时，仍可能指向一个"),t("code",[s._v('"被部分初始化的对象"')])]),s._v("。")]),s._v(" "),t("p",[s._v("问题出在这行简单的赋值语句：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("instance = new Singleton();\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("它并不是一个原子操作。事实上，它可以”抽象“为下面几条JVM指令：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("memory = allocate();    //1：分配对象的内存空间\ninitInstance(memory);   //2：初始化对象\ninstance = memory;      //3：设置instance指向刚分配的内存地址\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("上面"),t("em",[s._v("操作2依赖于操作1，但是操作3并不依赖于操作2")]),s._v("，所以JVM可以以“优化”为目的对它们进行"),t("code",[s._v("重排序")]),s._v("，经过重排序后如下：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("memory = allocate();    //1：分配对象的内存空间\ninstance = memory;      //3：设置instance指向刚分配的内存地址（此时对象还未初始化）\nctorInstance(memory);   //2：初始化对象\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("可以看到指令重排之后，操作 3 排在了操作 2 之前，即"),t("strong",[s._v("引用instance指向内存memory时，这段崭新的内存还没有初始化")]),s._v('——即，引用instance指向了一个"被部分初始化的对象"。此时，如果另一个线程调用getInstance方法，'),t("em",[s._v("由于instance已经指向了一块内存空间，从而if条件判为false，方法返回instance引用")]),s._v("，用户得到了没有完成初始化的“半个”单例。")]),s._v(" "),t("p",[s._v("解决这个该问题，只需要将instance声明为volatile变量：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("private static volatile Singleton instance;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("也就是说，"),t("strong",[s._v("在只有DCL没有volatile的懒加载单例模式中，仍然存在着并发陷阱")]),s._v("。我确实不会拿到"),t("code",[s._v("两个不同的单例")]),s._v("了，但我会拿到"),t("code",[s._v("“半个”单例")]),s._v("（未完成初始化）。")]),s._v(" "),t("p",[s._v("然而，许多面试书籍中，涉及懒加载的单例模式最多深入到DCL，却只字不提volatile。这“看似聪明”的机制，曾经被我广大初入Java世界的猿胞大加吹捧——我在大四实习面试跟谁学的时候，也得意洋洋的从饱汉、饿汉讲到Double Check，现在看来真是傻逼。对于考查并发的面试官而言，单例模式的实现就是一个很好的切入点，看似考查设计模式，其实期望你从设计模式答到并发和内存模型。")]),s._v(" "),t("p",[s._v("大家可以点击加群【JAVA架构知识学习讨论群】"),t("strong",[s._v("473984645")]),s._v(",（如多你想跳槽换工作，但是技术又不够，或者工作遇到了瓶颈，我这里有一个Java的免费直播课程，讲的是高端的知识点，只要有1-5年的开发工作经验可以加群找我要课堂链接。）注意：是免费的 没有开发经验的误入。")]),s._v(" "),t("h2",{attrs:{id:"volatile如何防止指令重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile如何防止指令重排"}},[s._v("#")]),s._v(" "),t("strong",[s._v("volatile如何防止指令重排")])]),s._v(" "),t("p",[s._v("volatile关键字通过"),t("code",[s._v("“内存屏障”")]),s._v("来防止指令被重排序。")]),s._v(" "),t("p",[s._v("为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。然而，对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。")]),s._v(" "),t("p",[s._v("下面是基于保守策略的JMM内存屏障插入策略：")]),s._v(" "),t("ul",[t("li",[s._v("在每个volatile写操作的前面插入一个StoreStore屏障。")]),s._v(" "),t("li",[s._v("在每个volatile写操作的后面插入一个StoreLoad屏障。")]),s._v(" "),t("li",[s._v("在每个volatile读操作的后面插入一个LoadLoad屏障。")]),s._v(" "),t("li",[s._v("在每个volatile读操作的后面插入一个LoadStore屏障。")])]),s._v(" "),t("h2",{attrs:{id:"进阶"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进阶"}},[s._v("#")]),s._v(" "),t("strong",[s._v("进阶")])]),s._v(" "),t("p",[s._v("在一次回答上述问题时，忘记了解释一个很容易引起疑惑的问题：")]),s._v(" "),t("p",[s._v("如果存在这种重排序问题，那么synchronized代码块内部不是也可能出现相同的问题吗？")]),s._v(" "),t("p",[s._v("即这种情况：")]),s._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Singleton {\n    ...\n        if ( instance == null ) { //可能发生不期望的指令重排\n            synchronized (Singleton.class) {\n                if ( instance == null ) {\n                    instance = new Singleton();\n                    System.out.println(instance.toString()); //程序顺序规则发挥效力的地方\n                }\n            }\n        }\n    ...\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("p",[s._v("难道调用"),t("code",[s._v("instance.toString()")]),s._v("方法时，instance也可能未完成初始化吗？")]),s._v(" "),t("p",[s._v("首先还请放宽心，"),t("strong",[s._v("synchronized代码块内部虽然会重排序，但不会在代码块的范围内导致线程安全问题")]),s._v("。")]),s._v(" "),t("h3",{attrs:{id:"happens-before内存模型和程序顺序规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before内存模型和程序顺序规则"}},[s._v("#")]),s._v(" "),t("strong",[s._v("Happens-Before内存模型和程序顺序规则")])]),s._v(" "),t("blockquote",[t("p",[s._v("程序顺序规则：如果程序中操作A在操作B之前，那么线程中操作A将在操作B之前执行。")])]),s._v(" "),t("p",[s._v("前面说过，"),t("strong",[s._v("只有在Happens-Before内存模型中才会出现这样的指令重排序问题")]),s._v("。Happens-Before内存模型维护了几种Happens-Before规则，"),t("code",[s._v("程序顺序规则")]),s._v("最基本的规则。程序顺序规则的目标对象是一段程序代码中的两个操作A、B，其"),t("strong",[s._v("保证此处的指令重排不会破坏操作A、B在代码中的先后顺序，但与不同代码甚至不同线程中的顺序无关")]),s._v("。")]),s._v(" "),t("p",[s._v("因此，在synchronized代码块内部，"),t("code",[s._v("instance = new Singleton()")]),s._v("仍然会指令重排序，但重排序之后的所有指令，仍然能够保证在"),t("code",[s._v("instance.toString()")]),s._v("之前执行。进一步的，单线程中，"),t("code",[s._v("if ( instance == null )")]),s._v("能保证在synchronized代码块之前执行；但多线程中，线程1中的"),t("code",[s._v("if ( instance == null )")]),s._v("却与线程2中的synchronized代码块之间没有偏序关系，因此线程2中synchronized代码块内部的指令重排对于线程1是不期望的，导致了此处的并发陷阱。")]),s._v(" "),t("blockquote",[t("p",[s._v("类似的Happens-Before规则还有"),t("code",[s._v("volatile变量规则")]),s._v("、"),t("code",[s._v("监视器锁规则")]),s._v("等。程序猿可以"),t("code",[s._v("借助")]),s._v("（Piggyback）现有的Happens-Before规则来保持内存可见性和防止指令重排。")])]),s._v(" "),t("h2",{attrs:{id:"注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[s._v("#")]),s._v(" "),t("strong",[s._v("注意点")])]),s._v(" "),t("p",[s._v("上面简单讲解了volatile关键字的作用和原理，但对volatile的使用过程中很容易出现的一个问题是：")]),s._v(" "),t("blockquote",[t("p",[s._v("错把volatile变量当做原子变量。")])]),s._v(" "),t("p",[s._v("出现这种误解的原因，主要是"),t("strong",[s._v("volatile关键字使变量的读、写具有了“原子性”")]),s._v("。然而这种原子性"),t("em",[s._v("仅限于变量（包括引用）的读和写，无法涵盖变量上的任何操作")]),s._v("，即：")]),s._v(" "),t("ul",[t("li",[s._v("基本类型的自增（如"),t("code",[s._v("count++")]),s._v("）等操作不是原子的。")]),s._v(" "),t("li",[s._v("对象的任何非原子成员调用（包括"),t("code",[s._v("成员变量")]),s._v("和"),t("code",[s._v("成员方法")]),s._v("）不是原子的。")])]),s._v(" "),t("p",[s._v("如果希望上述操作也具有原子性，那么只能采取锁、原子变量更多的措施。")]),s._v(" "),t("p",[s._v("以上内容转载自 "),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/90666838",target:"_blank",rel:"noopener noreferrer"}},[s._v("知乎"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);