(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{508:function(v,_,t){"use strict";t.r(_);var a=t(4),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",[v._v("本文摘自于CSDN，收录学习，文末附有传送门")])]),v._v(" "),t("h2",{attrs:{id:"二叉查找-搜索-排序树-bst-binary-search-sort-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉查找-搜索-排序树-bst-binary-search-sort-tree"}},[v._v("#")]),v._v(" 二叉查找/搜索/排序树  BST  (binary search/sort tree)")]),v._v(" "),t("p",[v._v("是一棵空树；或者是具有下列性质的二叉树：\n（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；\n（2）若它的右子树上所有结点的值均大于它的根节点的值；\n（3）它的左、右子树也分别为二叉排序树。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/20181004102705475.png",alt:"img"}})]),v._v(" "),t("p",[t("strong",[v._v("二叉树")]),v._v("：每个节点最多只能有两个子节点的树型结构。超过两个节点的成为多路树。")]),v._v(" "),t("p",[t("strong",[v._v("二叉搜索树")]),v._v("：二叉搜索树是特殊的二叉树，需满足要求：若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不为空，则它的右子树上所有节点的值均大于它的根节点的值。它的左右子树也分别为二叉排序树。")]),v._v(" "),t("h2",{attrs:{id:"平衡二叉树（self-balancing-binary-search-tree）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树（self-balancing-binary-search-tree）"}},[v._v("#")]),v._v(" 平衡二叉树（Self-balancing binary search tree）")]),v._v(" "),t("p",[v._v("平衡二叉查找树  又被称为AVL树（有别于AVL算法）")]),v._v(" "),t("p",[v._v("它是一 棵空树或它的左右两个子树的高度差(平衡因子)的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/20181004102938486.png",alt:"img"}})]),v._v(" "),t("p",[v._v("平衡因子（平衡度）：结点的平衡因子是结点的左子树的高度减去右子树的高度。（或反之定义）")]),v._v(" "),t("p",[v._v("平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。")]),v._v(" "),t("p",[v._v("平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度")]),v._v(" "),t("p",[v._v("平衡二叉树的常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等")]),v._v(" "),t("p",[v._v("如果是在平衡的二叉搜索树上，也就是说如果插入的数据是随机的，则其效率很高，其查找、插入和删除的时间复杂度都是O(logn)，底数为2；如果插入的数据是有序的，比如从小到大的顺序，则数据的排布效果全部在根节点的右边，和链表没什么区别，这种情况下的时间复杂度为O(n)，而不是O(logn)，当然这是在最不平衡的条件下，实际情况下，二叉搜索树的效率应该在O(n)和O(logn)之间，这取决于树的不平衡度。")]),v._v(" "),t("h2",{attrs:{id:"红-黑树-red-black-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#红-黑树-red-black-tree"}},[v._v("#")]),v._v(" 红-黑树 (Red-Black Tree)")]),v._v(" "),t("p",[v._v("R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)")]),v._v(" "),t("p",[v._v("特性：")]),v._v(" "),t("p",[v._v("（1）每个节点或者是黑色，或者是红色。\n（2）根节点是黑色。\n（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n（4）如果一个节点是红色的，则它的子节点必须是黑色的。\n（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。")]),v._v(" "),t("p",[v._v("注意：\n(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。\n(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/2018100410311231.png",alt:"img"}})]),v._v(" "),t("p",[v._v("红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。")]),v._v(" "),t("p",[v._v("它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。")]),v._v(" "),t("p",[v._v("例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。")]),v._v(" "),t("h2",{attrs:{id:"b-树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[v._v("#")]),v._v(" B-树")]),v._v(" "),t("p",[v._v("B-树是一种多路搜索树（并不一定是二叉的）")]),v._v(" "),t("p",[v._v("一棵**m阶B树(balanced tree of order m)**是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：")]),v._v(" "),t("p",[v._v("1、根结点至少有两个子女；")]),v._v(" "),t("p",[v._v("2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；")]),v._v(" "),t("p",[v._v("3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ <= k <= m ；")]),v._v(" "),t("p",[v._v("4、所有的叶子结点都位于同一层。")]),v._v(" "),t("p",[t("strong",[v._v("特点：")])]),v._v(" "),t("p",[v._v("是一种多路搜索树（并不是二叉的）：")]),v._v(" "),t("p",[v._v("1.定义任意非叶子结点最多只有M个儿子；且M>2；")]),v._v(" "),t("p",[v._v("2.根结点的儿子数为[2, M]；")]),v._v(" "),t("p",[v._v("3.除根结点以外的非叶子结点的儿子数为[M/2, M]；")]),v._v(" "),t("p",[v._v("4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）")]),v._v(" "),t("p",[v._v("5.非叶子结点的关键字个数=指向儿子的指针个数-1；")]),v._v(" "),t("p",[v._v("6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；")]),v._v(" "),t("p",[v._v("7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；")]),v._v(" "),t("p",[v._v("8.所有叶子结点位于同一层；")]),v._v(" "),t("p",[t("strong",[v._v("如：（M=3）")])]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/20160805191715603.png",alt:"img"}})]),v._v(" "),t("p",[v._v("B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；")]),v._v(" "),t("p",[t("strong",[v._v("特性")]),v._v("：")]),v._v(" "),t("p",[v._v("1.关键字集合分布在整颗树中；")]),v._v(" "),t("p",[v._v("2.任何一个关键字出现且只出现在一个结点中；")]),v._v(" "),t("p",[v._v("3.搜索有可能在非叶子结点结束；")]),v._v(" "),t("p",[v._v("4.其搜索性能等价于在关键字全集内做一次二分查找；")]),v._v(" "),t("p",[v._v("5.自动层次控制；")]),v._v(" "),t("h2",{attrs:{id:"b-树-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树-2"}},[v._v("#")]),v._v(" B+树")]),v._v(" "),t("p",[v._v("B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。")]),v._v(" "),t("p",[t("strong",[v._v("用途：")])]),v._v(" "),t("p",[v._v("B+ 树通常用于"),t("a",{attrs:{href:"http://lib.csdn.net/base/14",target:"_blank",rel:"noopener noreferrer"}},[v._v("数据库"),t("OutboundLink")],1),v._v("和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。")]),v._v(" "),t("p",[t("strong",[v._v("与B-树的差异：")])]),v._v(" "),t("p",[v._v("1.有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。")]),v._v(" "),t("p",[v._v("2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。")]),v._v(" "),t("p",[v._v("3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。 通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。")]),v._v(" "),t("p",[t("strong",[v._v("特点：")])]),v._v(" "),t("p",[v._v("2.非叶子结点的子树指针与关键字个数相同；")]),v._v(" "),t("p",[v._v("3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）")]),v._v(" "),t("p",[v._v("5.为所有叶子结点增加一个链指针；")]),v._v(" "),t("p",[v._v("6.所有关键字都在叶子结点出现；")]),v._v(" "),t("p",[t("strong",[v._v("如：（M=3）")])]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/20160805192039968.png",alt:"img"}})]),v._v(" "),t("p",[v._v("B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找")]),v._v(" "),t("p",[t("strong",[v._v("特性：")])]),v._v(" "),t("p",[v._v("1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；")]),v._v(" "),t("p",[v._v("2.不可能在非叶子结点命中；")]),v._v(" "),t("p",[v._v("3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；")]),v._v(" "),t("p",[v._v("4.更适合文件索引系统；")]),v._v(" "),t("h2",{attrs:{id:"b-树-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树-3"}},[v._v("#")]),v._v(" B*树")]),v._v(" "),t("p",[v._v("是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://assert.pekst.com/image/20160805192156312.png",alt:"img"}})]),v._v(" "),t("p",[v._v("*"),t("em",[v._v("B*树定义了非叶子结点关键字个数至少为(2/3)"),t("em",[v._v("M，即块的最低使用率为2/3")])])]),v._v(" "),t("p",[t("strong",[v._v("B+树的分裂：")])]),v._v(" "),t("p",[v._v("当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针")]),v._v(" "),t("p",[t("strong",[v._v("B*树的分裂：")])]),v._v(" "),t("p",[v._v("当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针")]),v._v(" "),t("p",[t("strong",[v._v("所以，B*树分配新结点的概率比B+树要低，空间使用率更高")])]),v._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),t("h3",{attrs:{id:"b-树："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树："}},[v._v("#")]),v._v(" B-树：")]),v._v(" "),t("p",[v._v("多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；")]),v._v(" "),t("p",[v._v("所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；")]),v._v(" "),t("h3",{attrs:{id:"b-树：-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树：-2"}},[v._v("#")]),v._v(" B+树：")]),v._v(" "),t("p",[v._v("在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；")]),v._v(" "),t("p",[v._v("B+树总是到叶子结点才命中；")]),v._v(" "),t("h3",{attrs:{id:"b-树：-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树：-3"}},[v._v("#")]),v._v(" B*树：")]),v._v(" "),t("p",[v._v("在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；")]),v._v(" "),t("p",[v._v("以上内容转载自 "),t("a",{attrs:{href:"https://blog.csdn.net/wyqwilliam/article/details/82935922",target:"_blank",rel:"noopener noreferrer"}},[v._v("CSDN"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);